{"ast":null,"code":"function message(msg, actual, ...types) {\n  types = types.filter(Boolean);\n  if (types.length > 2) {\n    const last = types.pop();\n    msg += `one of type ${types.join(', ')}, or ${last}.`;\n  } else if (types.length === 2) {\n    msg += `one of type ${types[0]} or ${types[1]}.`;\n  } else {\n    msg += `of type ${types[0]}.`;\n  }\n  if (actual == null) {\n    msg += ` Received ${actual}`;\n  } else if (typeof actual === 'function' && actual.name) {\n    msg += ` Received function ${actual.name}`;\n  } else if (typeof actual === 'object' && actual != null) {\n    if (actual.constructor?.name) {\n      msg += ` Received an instance of ${actual.constructor.name}`;\n    }\n  }\n  return msg;\n}\nexport default (actual, ...types) => {\n  return message('Key must be ', actual, ...types);\n};\nexport function withAlg(alg, actual, ...types) {\n  return message(`Key for the ${alg} algorithm must be `, actual, ...types);\n}","map":{"version":3,"names":["message","msg","actual","types","filter","Boolean","length","last","pop","join","name","constructor","withAlg","alg"],"sources":["/home/kishan/NewBackEnd/frontend/node_modules/jose/dist/browser/lib/invalid_key_input.js"],"sourcesContent":["function message(msg, actual, ...types) {\n    types = types.filter(Boolean);\n    if (types.length > 2) {\n        const last = types.pop();\n        msg += `one of type ${types.join(', ')}, or ${last}.`;\n    }\n    else if (types.length === 2) {\n        msg += `one of type ${types[0]} or ${types[1]}.`;\n    }\n    else {\n        msg += `of type ${types[0]}.`;\n    }\n    if (actual == null) {\n        msg += ` Received ${actual}`;\n    }\n    else if (typeof actual === 'function' && actual.name) {\n        msg += ` Received function ${actual.name}`;\n    }\n    else if (typeof actual === 'object' && actual != null) {\n        if (actual.constructor?.name) {\n            msg += ` Received an instance of ${actual.constructor.name}`;\n        }\n    }\n    return msg;\n}\nexport default (actual, ...types) => {\n    return message('Key must be ', actual, ...types);\n};\nexport function withAlg(alg, actual, ...types) {\n    return message(`Key for the ${alg} algorithm must be `, actual, ...types);\n}\n"],"mappings":"AAAA,SAASA,OAAOA,CAACC,GAAG,EAAEC,MAAM,EAAE,GAAGC,KAAK,EAAE;EACpCA,KAAK,GAAGA,KAAK,CAACC,MAAM,CAACC,OAAO,CAAC;EAC7B,IAAIF,KAAK,CAACG,MAAM,GAAG,CAAC,EAAE;IAClB,MAAMC,IAAI,GAAGJ,KAAK,CAACK,GAAG,CAAC,CAAC;IACxBP,GAAG,IAAI,eAAeE,KAAK,CAACM,IAAI,CAAC,IAAI,CAAC,QAAQF,IAAI,GAAG;EACzD,CAAC,MACI,IAAIJ,KAAK,CAACG,MAAM,KAAK,CAAC,EAAE;IACzBL,GAAG,IAAI,eAAeE,KAAK,CAAC,CAAC,CAAC,OAAOA,KAAK,CAAC,CAAC,CAAC,GAAG;EACpD,CAAC,MACI;IACDF,GAAG,IAAI,WAAWE,KAAK,CAAC,CAAC,CAAC,GAAG;EACjC;EACA,IAAID,MAAM,IAAI,IAAI,EAAE;IAChBD,GAAG,IAAI,aAAaC,MAAM,EAAE;EAChC,CAAC,MACI,IAAI,OAAOA,MAAM,KAAK,UAAU,IAAIA,MAAM,CAACQ,IAAI,EAAE;IAClDT,GAAG,IAAI,sBAAsBC,MAAM,CAACQ,IAAI,EAAE;EAC9C,CAAC,MACI,IAAI,OAAOR,MAAM,KAAK,QAAQ,IAAIA,MAAM,IAAI,IAAI,EAAE;IACnD,IAAIA,MAAM,CAACS,WAAW,EAAED,IAAI,EAAE;MAC1BT,GAAG,IAAI,4BAA4BC,MAAM,CAACS,WAAW,CAACD,IAAI,EAAE;IAChE;EACJ;EACA,OAAOT,GAAG;AACd;AACA,eAAe,CAACC,MAAM,EAAE,GAAGC,KAAK,KAAK;EACjC,OAAOH,OAAO,CAAC,cAAc,EAAEE,MAAM,EAAE,GAAGC,KAAK,CAAC;AACpD,CAAC;AACD,OAAO,SAASS,OAAOA,CAACC,GAAG,EAAEX,MAAM,EAAE,GAAGC,KAAK,EAAE;EAC3C,OAAOH,OAAO,CAAC,eAAea,GAAG,qBAAqB,EAAEX,MAAM,EAAE,GAAGC,KAAK,CAAC;AAC7E","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}