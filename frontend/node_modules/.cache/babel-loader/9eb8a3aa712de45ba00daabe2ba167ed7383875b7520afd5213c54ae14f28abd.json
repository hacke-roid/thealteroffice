{"ast":null,"code":"import { encode as base64url } from '../../runtime/base64url.js';\nimport { unprotected } from '../../lib/private_symbols.js';\nimport encrypt from '../../runtime/encrypt.js';\nimport encryptKeyManagement from '../../lib/encrypt_key_management.js';\nimport { JOSENotSupported, JWEInvalid } from '../../util/errors.js';\nimport isDisjoint from '../../lib/is_disjoint.js';\nimport { encoder, decoder, concat } from '../../lib/buffer_utils.js';\nimport validateCrit from '../../lib/validate_crit.js';\nexport class FlattenedEncrypt {\n  constructor(plaintext) {\n    if (!(plaintext instanceof Uint8Array)) {\n      throw new TypeError('plaintext must be an instance of Uint8Array');\n    }\n    this._plaintext = plaintext;\n  }\n  setKeyManagementParameters(parameters) {\n    if (this._keyManagementParameters) {\n      throw new TypeError('setKeyManagementParameters can only be called once');\n    }\n    this._keyManagementParameters = parameters;\n    return this;\n  }\n  setProtectedHeader(protectedHeader) {\n    if (this._protectedHeader) {\n      throw new TypeError('setProtectedHeader can only be called once');\n    }\n    this._protectedHeader = protectedHeader;\n    return this;\n  }\n  setSharedUnprotectedHeader(sharedUnprotectedHeader) {\n    if (this._sharedUnprotectedHeader) {\n      throw new TypeError('setSharedUnprotectedHeader can only be called once');\n    }\n    this._sharedUnprotectedHeader = sharedUnprotectedHeader;\n    return this;\n  }\n  setUnprotectedHeader(unprotectedHeader) {\n    if (this._unprotectedHeader) {\n      throw new TypeError('setUnprotectedHeader can only be called once');\n    }\n    this._unprotectedHeader = unprotectedHeader;\n    return this;\n  }\n  setAdditionalAuthenticatedData(aad) {\n    this._aad = aad;\n    return this;\n  }\n  setContentEncryptionKey(cek) {\n    if (this._cek) {\n      throw new TypeError('setContentEncryptionKey can only be called once');\n    }\n    this._cek = cek;\n    return this;\n  }\n  setInitializationVector(iv) {\n    if (this._iv) {\n      throw new TypeError('setInitializationVector can only be called once');\n    }\n    this._iv = iv;\n    return this;\n  }\n  async encrypt(key, options) {\n    if (!this._protectedHeader && !this._unprotectedHeader && !this._sharedUnprotectedHeader) {\n      throw new JWEInvalid('either setProtectedHeader, setUnprotectedHeader, or sharedUnprotectedHeader must be called before #encrypt()');\n    }\n    if (!isDisjoint(this._protectedHeader, this._unprotectedHeader, this._sharedUnprotectedHeader)) {\n      throw new JWEInvalid('JWE Protected, JWE Shared Unprotected and JWE Per-Recipient Header Parameter names must be disjoint');\n    }\n    const joseHeader = {\n      ...this._protectedHeader,\n      ...this._unprotectedHeader,\n      ...this._sharedUnprotectedHeader\n    };\n    validateCrit(JWEInvalid, new Map(), options?.crit, this._protectedHeader, joseHeader);\n    if (joseHeader.zip !== undefined) {\n      throw new JOSENotSupported('JWE \"zip\" (Compression Algorithm) Header Parameter is not supported.');\n    }\n    const {\n      alg,\n      enc\n    } = joseHeader;\n    if (typeof alg !== 'string' || !alg) {\n      throw new JWEInvalid('JWE \"alg\" (Algorithm) Header Parameter missing or invalid');\n    }\n    if (typeof enc !== 'string' || !enc) {\n      throw new JWEInvalid('JWE \"enc\" (Encryption Algorithm) Header Parameter missing or invalid');\n    }\n    let encryptedKey;\n    if (this._cek && (alg === 'dir' || alg === 'ECDH-ES')) {\n      throw new TypeError(`setContentEncryptionKey cannot be called with JWE \"alg\" (Algorithm) Header ${alg}`);\n    }\n    let cek;\n    {\n      let parameters;\n      ({\n        cek,\n        encryptedKey,\n        parameters\n      } = await encryptKeyManagement(alg, enc, key, this._cek, this._keyManagementParameters));\n      if (parameters) {\n        if (options && unprotected in options) {\n          if (!this._unprotectedHeader) {\n            this.setUnprotectedHeader(parameters);\n          } else {\n            this._unprotectedHeader = {\n              ...this._unprotectedHeader,\n              ...parameters\n            };\n          }\n        } else if (!this._protectedHeader) {\n          this.setProtectedHeader(parameters);\n        } else {\n          this._protectedHeader = {\n            ...this._protectedHeader,\n            ...parameters\n          };\n        }\n      }\n    }\n    let additionalData;\n    let protectedHeader;\n    let aadMember;\n    if (this._protectedHeader) {\n      protectedHeader = encoder.encode(base64url(JSON.stringify(this._protectedHeader)));\n    } else {\n      protectedHeader = encoder.encode('');\n    }\n    if (this._aad) {\n      aadMember = base64url(this._aad);\n      additionalData = concat(protectedHeader, encoder.encode('.'), encoder.encode(aadMember));\n    } else {\n      additionalData = protectedHeader;\n    }\n    const {\n      ciphertext,\n      tag,\n      iv\n    } = await encrypt(enc, this._plaintext, cek, this._iv, additionalData);\n    const jwe = {\n      ciphertext: base64url(ciphertext)\n    };\n    if (iv) {\n      jwe.iv = base64url(iv);\n    }\n    if (tag) {\n      jwe.tag = base64url(tag);\n    }\n    if (encryptedKey) {\n      jwe.encrypted_key = base64url(encryptedKey);\n    }\n    if (aadMember) {\n      jwe.aad = aadMember;\n    }\n    if (this._protectedHeader) {\n      jwe.protected = decoder.decode(protectedHeader);\n    }\n    if (this._sharedUnprotectedHeader) {\n      jwe.unprotected = this._sharedUnprotectedHeader;\n    }\n    if (this._unprotectedHeader) {\n      jwe.header = this._unprotectedHeader;\n    }\n    return jwe;\n  }\n}","map":{"version":3,"names":["encode","base64url","unprotected","encrypt","encryptKeyManagement","JOSENotSupported","JWEInvalid","isDisjoint","encoder","decoder","concat","validateCrit","FlattenedEncrypt","constructor","plaintext","Uint8Array","TypeError","_plaintext","setKeyManagementParameters","parameters","_keyManagementParameters","setProtectedHeader","protectedHeader","_protectedHeader","setSharedUnprotectedHeader","sharedUnprotectedHeader","_sharedUnprotectedHeader","setUnprotectedHeader","unprotectedHeader","_unprotectedHeader","setAdditionalAuthenticatedData","aad","_aad","setContentEncryptionKey","cek","_cek","setInitializationVector","iv","_iv","key","options","joseHeader","Map","crit","zip","undefined","alg","enc","encryptedKey","additionalData","aadMember","JSON","stringify","ciphertext","tag","jwe","encrypted_key","protected","decode","header"],"sources":["/home/kishan/NewBackEnd/frontend/node_modules/jose/dist/browser/jwe/flattened/encrypt.js"],"sourcesContent":["import { encode as base64url } from '../../runtime/base64url.js';\nimport { unprotected } from '../../lib/private_symbols.js';\nimport encrypt from '../../runtime/encrypt.js';\nimport encryptKeyManagement from '../../lib/encrypt_key_management.js';\nimport { JOSENotSupported, JWEInvalid } from '../../util/errors.js';\nimport isDisjoint from '../../lib/is_disjoint.js';\nimport { encoder, decoder, concat } from '../../lib/buffer_utils.js';\nimport validateCrit from '../../lib/validate_crit.js';\nexport class FlattenedEncrypt {\n    constructor(plaintext) {\n        if (!(plaintext instanceof Uint8Array)) {\n            throw new TypeError('plaintext must be an instance of Uint8Array');\n        }\n        this._plaintext = plaintext;\n    }\n    setKeyManagementParameters(parameters) {\n        if (this._keyManagementParameters) {\n            throw new TypeError('setKeyManagementParameters can only be called once');\n        }\n        this._keyManagementParameters = parameters;\n        return this;\n    }\n    setProtectedHeader(protectedHeader) {\n        if (this._protectedHeader) {\n            throw new TypeError('setProtectedHeader can only be called once');\n        }\n        this._protectedHeader = protectedHeader;\n        return this;\n    }\n    setSharedUnprotectedHeader(sharedUnprotectedHeader) {\n        if (this._sharedUnprotectedHeader) {\n            throw new TypeError('setSharedUnprotectedHeader can only be called once');\n        }\n        this._sharedUnprotectedHeader = sharedUnprotectedHeader;\n        return this;\n    }\n    setUnprotectedHeader(unprotectedHeader) {\n        if (this._unprotectedHeader) {\n            throw new TypeError('setUnprotectedHeader can only be called once');\n        }\n        this._unprotectedHeader = unprotectedHeader;\n        return this;\n    }\n    setAdditionalAuthenticatedData(aad) {\n        this._aad = aad;\n        return this;\n    }\n    setContentEncryptionKey(cek) {\n        if (this._cek) {\n            throw new TypeError('setContentEncryptionKey can only be called once');\n        }\n        this._cek = cek;\n        return this;\n    }\n    setInitializationVector(iv) {\n        if (this._iv) {\n            throw new TypeError('setInitializationVector can only be called once');\n        }\n        this._iv = iv;\n        return this;\n    }\n    async encrypt(key, options) {\n        if (!this._protectedHeader && !this._unprotectedHeader && !this._sharedUnprotectedHeader) {\n            throw new JWEInvalid('either setProtectedHeader, setUnprotectedHeader, or sharedUnprotectedHeader must be called before #encrypt()');\n        }\n        if (!isDisjoint(this._protectedHeader, this._unprotectedHeader, this._sharedUnprotectedHeader)) {\n            throw new JWEInvalid('JWE Protected, JWE Shared Unprotected and JWE Per-Recipient Header Parameter names must be disjoint');\n        }\n        const joseHeader = {\n            ...this._protectedHeader,\n            ...this._unprotectedHeader,\n            ...this._sharedUnprotectedHeader,\n        };\n        validateCrit(JWEInvalid, new Map(), options?.crit, this._protectedHeader, joseHeader);\n        if (joseHeader.zip !== undefined) {\n            throw new JOSENotSupported('JWE \"zip\" (Compression Algorithm) Header Parameter is not supported.');\n        }\n        const { alg, enc } = joseHeader;\n        if (typeof alg !== 'string' || !alg) {\n            throw new JWEInvalid('JWE \"alg\" (Algorithm) Header Parameter missing or invalid');\n        }\n        if (typeof enc !== 'string' || !enc) {\n            throw new JWEInvalid('JWE \"enc\" (Encryption Algorithm) Header Parameter missing or invalid');\n        }\n        let encryptedKey;\n        if (this._cek && (alg === 'dir' || alg === 'ECDH-ES')) {\n            throw new TypeError(`setContentEncryptionKey cannot be called with JWE \"alg\" (Algorithm) Header ${alg}`);\n        }\n        let cek;\n        {\n            let parameters;\n            ({ cek, encryptedKey, parameters } = await encryptKeyManagement(alg, enc, key, this._cek, this._keyManagementParameters));\n            if (parameters) {\n                if (options && unprotected in options) {\n                    if (!this._unprotectedHeader) {\n                        this.setUnprotectedHeader(parameters);\n                    }\n                    else {\n                        this._unprotectedHeader = { ...this._unprotectedHeader, ...parameters };\n                    }\n                }\n                else if (!this._protectedHeader) {\n                    this.setProtectedHeader(parameters);\n                }\n                else {\n                    this._protectedHeader = { ...this._protectedHeader, ...parameters };\n                }\n            }\n        }\n        let additionalData;\n        let protectedHeader;\n        let aadMember;\n        if (this._protectedHeader) {\n            protectedHeader = encoder.encode(base64url(JSON.stringify(this._protectedHeader)));\n        }\n        else {\n            protectedHeader = encoder.encode('');\n        }\n        if (this._aad) {\n            aadMember = base64url(this._aad);\n            additionalData = concat(protectedHeader, encoder.encode('.'), encoder.encode(aadMember));\n        }\n        else {\n            additionalData = protectedHeader;\n        }\n        const { ciphertext, tag, iv } = await encrypt(enc, this._plaintext, cek, this._iv, additionalData);\n        const jwe = {\n            ciphertext: base64url(ciphertext),\n        };\n        if (iv) {\n            jwe.iv = base64url(iv);\n        }\n        if (tag) {\n            jwe.tag = base64url(tag);\n        }\n        if (encryptedKey) {\n            jwe.encrypted_key = base64url(encryptedKey);\n        }\n        if (aadMember) {\n            jwe.aad = aadMember;\n        }\n        if (this._protectedHeader) {\n            jwe.protected = decoder.decode(protectedHeader);\n        }\n        if (this._sharedUnprotectedHeader) {\n            jwe.unprotected = this._sharedUnprotectedHeader;\n        }\n        if (this._unprotectedHeader) {\n            jwe.header = this._unprotectedHeader;\n        }\n        return jwe;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}