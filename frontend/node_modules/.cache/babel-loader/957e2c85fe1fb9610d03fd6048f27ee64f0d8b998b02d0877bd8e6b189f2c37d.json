{"ast":null,"code":"import { JWTClaimValidationFailed, JWTExpired, JWTInvalid } from '../util/errors.js';\nimport { decoder } from './buffer_utils.js';\nimport epoch from './epoch.js';\nimport secs from './secs.js';\nimport isObject from './is_object.js';\nconst normalizeTyp = value => value.toLowerCase().replace(/^application\\//, '');\nconst checkAudiencePresence = (audPayload, audOption) => {\n  if (typeof audPayload === 'string') {\n    return audOption.includes(audPayload);\n  }\n  if (Array.isArray(audPayload)) {\n    return audOption.some(Set.prototype.has.bind(new Set(audPayload)));\n  }\n  return false;\n};\nexport default (protectedHeader, encodedPayload, options = {}) => {\n  let payload;\n  try {\n    payload = JSON.parse(decoder.decode(encodedPayload));\n  } catch {}\n  if (!isObject(payload)) {\n    throw new JWTInvalid('JWT Claims Set must be a top-level JSON object');\n  }\n  const {\n    typ\n  } = options;\n  if (typ && (typeof protectedHeader.typ !== 'string' || normalizeTyp(protectedHeader.typ) !== normalizeTyp(typ))) {\n    throw new JWTClaimValidationFailed('unexpected \"typ\" JWT header value', payload, 'typ', 'check_failed');\n  }\n  const {\n    requiredClaims = [],\n    issuer,\n    subject,\n    audience,\n    maxTokenAge\n  } = options;\n  const presenceCheck = [...requiredClaims];\n  if (maxTokenAge !== undefined) presenceCheck.push('iat');\n  if (audience !== undefined) presenceCheck.push('aud');\n  if (subject !== undefined) presenceCheck.push('sub');\n  if (issuer !== undefined) presenceCheck.push('iss');\n  for (const claim of new Set(presenceCheck.reverse())) {\n    if (!(claim in payload)) {\n      throw new JWTClaimValidationFailed(`missing required \"${claim}\" claim`, payload, claim, 'missing');\n    }\n  }\n  if (issuer && !(Array.isArray(issuer) ? issuer : [issuer]).includes(payload.iss)) {\n    throw new JWTClaimValidationFailed('unexpected \"iss\" claim value', payload, 'iss', 'check_failed');\n  }\n  if (subject && payload.sub !== subject) {\n    throw new JWTClaimValidationFailed('unexpected \"sub\" claim value', payload, 'sub', 'check_failed');\n  }\n  if (audience && !checkAudiencePresence(payload.aud, typeof audience === 'string' ? [audience] : audience)) {\n    throw new JWTClaimValidationFailed('unexpected \"aud\" claim value', payload, 'aud', 'check_failed');\n  }\n  let tolerance;\n  switch (typeof options.clockTolerance) {\n    case 'string':\n      tolerance = secs(options.clockTolerance);\n      break;\n    case 'number':\n      tolerance = options.clockTolerance;\n      break;\n    case 'undefined':\n      tolerance = 0;\n      break;\n    default:\n      throw new TypeError('Invalid clockTolerance option type');\n  }\n  const {\n    currentDate\n  } = options;\n  const now = epoch(currentDate || new Date());\n  if ((payload.iat !== undefined || maxTokenAge) && typeof payload.iat !== 'number') {\n    throw new JWTClaimValidationFailed('\"iat\" claim must be a number', payload, 'iat', 'invalid');\n  }\n  if (payload.nbf !== undefined) {\n    if (typeof payload.nbf !== 'number') {\n      throw new JWTClaimValidationFailed('\"nbf\" claim must be a number', payload, 'nbf', 'invalid');\n    }\n    if (payload.nbf > now + tolerance) {\n      throw new JWTClaimValidationFailed('\"nbf\" claim timestamp check failed', payload, 'nbf', 'check_failed');\n    }\n  }\n  if (payload.exp !== undefined) {\n    if (typeof payload.exp !== 'number') {\n      throw new JWTClaimValidationFailed('\"exp\" claim must be a number', payload, 'exp', 'invalid');\n    }\n    if (payload.exp <= now - tolerance) {\n      throw new JWTExpired('\"exp\" claim timestamp check failed', payload, 'exp', 'check_failed');\n    }\n  }\n  if (maxTokenAge) {\n    const age = now - payload.iat;\n    const max = typeof maxTokenAge === 'number' ? maxTokenAge : secs(maxTokenAge);\n    if (age - tolerance > max) {\n      throw new JWTExpired('\"iat\" claim timestamp check failed (too far in the past)', payload, 'iat', 'check_failed');\n    }\n    if (age < 0 - tolerance) {\n      throw new JWTClaimValidationFailed('\"iat\" claim timestamp check failed (it should be in the past)', payload, 'iat', 'check_failed');\n    }\n  }\n  return payload;\n};","map":{"version":3,"names":["JWTClaimValidationFailed","JWTExpired","JWTInvalid","decoder","epoch","secs","isObject","normalizeTyp","value","toLowerCase","replace","checkAudiencePresence","audPayload","audOption","includes","Array","isArray","some","Set","prototype","has","bind","protectedHeader","encodedPayload","options","payload","JSON","parse","decode","typ","requiredClaims","issuer","subject","audience","maxTokenAge","presenceCheck","undefined","push","claim","reverse","iss","sub","aud","tolerance","clockTolerance","TypeError","currentDate","now","Date","iat","nbf","exp","age","max"],"sources":["/home/kishan/NewBackEnd/frontend/node_modules/jose/dist/browser/lib/jwt_claims_set.js"],"sourcesContent":["import { JWTClaimValidationFailed, JWTExpired, JWTInvalid } from '../util/errors.js';\nimport { decoder } from './buffer_utils.js';\nimport epoch from './epoch.js';\nimport secs from './secs.js';\nimport isObject from './is_object.js';\nconst normalizeTyp = (value) => value.toLowerCase().replace(/^application\\//, '');\nconst checkAudiencePresence = (audPayload, audOption) => {\n    if (typeof audPayload === 'string') {\n        return audOption.includes(audPayload);\n    }\n    if (Array.isArray(audPayload)) {\n        return audOption.some(Set.prototype.has.bind(new Set(audPayload)));\n    }\n    return false;\n};\nexport default (protectedHeader, encodedPayload, options = {}) => {\n    let payload;\n    try {\n        payload = JSON.parse(decoder.decode(encodedPayload));\n    }\n    catch {\n    }\n    if (!isObject(payload)) {\n        throw new JWTInvalid('JWT Claims Set must be a top-level JSON object');\n    }\n    const { typ } = options;\n    if (typ &&\n        (typeof protectedHeader.typ !== 'string' ||\n            normalizeTyp(protectedHeader.typ) !== normalizeTyp(typ))) {\n        throw new JWTClaimValidationFailed('unexpected \"typ\" JWT header value', payload, 'typ', 'check_failed');\n    }\n    const { requiredClaims = [], issuer, subject, audience, maxTokenAge } = options;\n    const presenceCheck = [...requiredClaims];\n    if (maxTokenAge !== undefined)\n        presenceCheck.push('iat');\n    if (audience !== undefined)\n        presenceCheck.push('aud');\n    if (subject !== undefined)\n        presenceCheck.push('sub');\n    if (issuer !== undefined)\n        presenceCheck.push('iss');\n    for (const claim of new Set(presenceCheck.reverse())) {\n        if (!(claim in payload)) {\n            throw new JWTClaimValidationFailed(`missing required \"${claim}\" claim`, payload, claim, 'missing');\n        }\n    }\n    if (issuer &&\n        !(Array.isArray(issuer) ? issuer : [issuer]).includes(payload.iss)) {\n        throw new JWTClaimValidationFailed('unexpected \"iss\" claim value', payload, 'iss', 'check_failed');\n    }\n    if (subject && payload.sub !== subject) {\n        throw new JWTClaimValidationFailed('unexpected \"sub\" claim value', payload, 'sub', 'check_failed');\n    }\n    if (audience &&\n        !checkAudiencePresence(payload.aud, typeof audience === 'string' ? [audience] : audience)) {\n        throw new JWTClaimValidationFailed('unexpected \"aud\" claim value', payload, 'aud', 'check_failed');\n    }\n    let tolerance;\n    switch (typeof options.clockTolerance) {\n        case 'string':\n            tolerance = secs(options.clockTolerance);\n            break;\n        case 'number':\n            tolerance = options.clockTolerance;\n            break;\n        case 'undefined':\n            tolerance = 0;\n            break;\n        default:\n            throw new TypeError('Invalid clockTolerance option type');\n    }\n    const { currentDate } = options;\n    const now = epoch(currentDate || new Date());\n    if ((payload.iat !== undefined || maxTokenAge) && typeof payload.iat !== 'number') {\n        throw new JWTClaimValidationFailed('\"iat\" claim must be a number', payload, 'iat', 'invalid');\n    }\n    if (payload.nbf !== undefined) {\n        if (typeof payload.nbf !== 'number') {\n            throw new JWTClaimValidationFailed('\"nbf\" claim must be a number', payload, 'nbf', 'invalid');\n        }\n        if (payload.nbf > now + tolerance) {\n            throw new JWTClaimValidationFailed('\"nbf\" claim timestamp check failed', payload, 'nbf', 'check_failed');\n        }\n    }\n    if (payload.exp !== undefined) {\n        if (typeof payload.exp !== 'number') {\n            throw new JWTClaimValidationFailed('\"exp\" claim must be a number', payload, 'exp', 'invalid');\n        }\n        if (payload.exp <= now - tolerance) {\n            throw new JWTExpired('\"exp\" claim timestamp check failed', payload, 'exp', 'check_failed');\n        }\n    }\n    if (maxTokenAge) {\n        const age = now - payload.iat;\n        const max = typeof maxTokenAge === 'number' ? maxTokenAge : secs(maxTokenAge);\n        if (age - tolerance > max) {\n            throw new JWTExpired('\"iat\" claim timestamp check failed (too far in the past)', payload, 'iat', 'check_failed');\n        }\n        if (age < 0 - tolerance) {\n            throw new JWTClaimValidationFailed('\"iat\" claim timestamp check failed (it should be in the past)', payload, 'iat', 'check_failed');\n        }\n    }\n    return payload;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}